
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  科学技术 - 书摘
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="Reading makes a full man.">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="书摘" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">书摘</a></h1>
  
    <h2>Reading makes a full man.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:azureyu.com/book" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_self" href="category.html">category</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14602167513069.html">iOS 8 Programming Fundamental with Swift [Note]</a></h1>
			<p class="meta"><time datetime="2016-04-09T23:45:51+08:00" 
			pubdate data-updated="true">2016/4/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>[TOC]</p>

<h1>Part 2 IDE</h1>

<h1>Chapter 6. Anatomy of an Xcode Project</h1>

<h2>从项目到可运行的App</h2>

<p>App文件其实就是一个特殊的叫作<em>package</em>的文件夹。<br/>
假设应用名为Empty Window<br/>
<img src="/img/package.png" alt="package"/></p>

<p>Empty window: 编译的文件。<br/>
Main.Storyboard:Storyboard 文件，a bundle of nibs files.按需加载。<br/>
Info.list : 配置文件。<br/>
Frameworks: 需添加的框架。<br/>
PkgInfo: 历史遗留物。</p>

<h2>Build Settings</h2>

<p>属性列表文件就是一系列的键对值。</p>

<ul>
<li>修改Info.plist文件 Editor-&gt;Show raw values.</li>
</ul>

<h2>Nib Files</h2>

<p>一个Nib文件是一部分用户界面描述，它以已编译的格式包含在一个以<em>.nib结尾</em>的文件里。</p>

<p>它是在编译过程中由<code>.xib</code>文件生成的,相应的，包含多个nib文件的<code>.storyboardc</code>由<br/>
<code>.storyboard</code>文件生成。</p>

<h2>Code File and App Launch Process</h2>

<h3>The entry point</h3>

<p>写过C语言的都知道，程序进入开始执行的地方是main函数。同样的在Objective-C中也是。</p>

<pre><code>int main(int argh, char *argv[]) {
        @autoreleasepool {
            return UIApplicationMain(argh, argue, nil,
                NSStringFromClass([AppDelegate class]));
} } 
</code></pre>

<p>做了两件事情:</p>

<ul>
<li>设置了内存管理环境</li>
<li>调用了UIApplicationMain函数</li>
</ul>

<p>但在swift中你找不到main函数：</p>

<pre><code>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {...}
</code></pre>

<p>上面的@UIApplicationMain属性，就实现了main函数的功能。你也可以自定义，新建main.swift(必须以main命名)，在其中写：</p>

<pre><code>import UIKit
UIApplicationMain(
    Process.argc, Process.unsafeArgv, nil, NSStringFromClass(AppDelegate))
</code></pre>

<h3>UIApplicationMain</h3>

<p>其实你的App不过就是对单个巨大的UIApplictionMain函数的调用。（想一想C语言中main函数的调用执行）</p>

<p>UIApplicationMain主要做的事：</p>

<ol>
<li>创建你app的第一个实例——共享应用实例(the shared application instance)。之后，你可以很容易的通过调用UIApplication.sharedApplication()得到该实例。UIApplicationMain调用的第三个参数，指定了应该实例化哪一个共享应用实例。默认是nil，如果你想使用一个自己写的子类，就可以改为NSStringFromClass(MyUIApplicationSubclass)（MyUIApplicationSubclass是你自己的子类名）。</li>
<li>创建你的第二个实例—— 应用实例的代理(delegate)。同理，它对应第四个参数。</li>
<li>如果Info.list指定了一个主故事板文件(main storyboard file)，UIApplicationMain就会加载并查找它的初始视图控制器(initial view controller)。UIApplicationMain会实例化该视图控制器。</li>
<li>如果有一个主故事板文件，UIApplicationMain就会开始创建窗口(<code>Window</code>)。它是你app的第四个实例，是UIWindows的实例。赋给应用代理的window属性，初始化视图控制器赋给窗口实例（window instance）的rootViewController属性。</li>
<li>UIApplicationMain转向app delegate instance并开始调用其中的代码。终于，你可以在其中写自己的代码了。但是，最好只做一些<strong>不费时</strong>的初始化工作，因为这个时候应用的界面还没有显示。</li>
<li>如果有一个主故事板，UIApplicationMain现在回让它显示出来了。它通过调用UIWindow实例中的<code>makeKeyandVisible</code>方法来实现。</li>
<li>现在窗口马上就会显示了。</li>
</ol>

<p>如果没有指定一个主故事板，你也可以自己写：</p>

<pre><code>    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?

        // look, ma, no storyboard!
        fun application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
            self.window = UIWindow()
            self.window!.backgroundColor = UIColor.whiteColor()
            self.window!.rootViewController =
                MyViewController(nibName:&quot;MyViewController&quot;, bundle:nil)
            self.window!.makeKeyAndVisible()
            return true
        }
    }
</code></pre>

<p><code>framework</code>:已编译的代码库。<br/>
对设备系统framework子集的复制叫做<code>SDK</code>(software development kit)。</p>

<p>链接(<code>Linking</code>)是将你的已编译代码与所需框架挂钩的过程。</p>

<p>Swift使用Modules。Modules会自动编译。<br/>
Modules是缓存信息，存放在Library/Developer/Xcode/DrivedData/ModulesCache.它精巧而方便，但也有缺点，你无法确切的指定自己使用了哪些框架。响应的头文件也不会在导航中显示。</p>

<p>有些情况下你也需要手动添加框架：<br/>
<img src="/img/linking.png" alt="linking"/></p>

<hr/>

<h2>Cocoa</h2>

<p>在进行iOS编程时，多数情况下是在与Cocoa进行交互。<br/>
Cocoa是一个很庞大的库，它分为了几个小库。</p>

<h2>Subclassing</h2>

<p>Cocoa会提供给你一些可以直接使用的对象，比如UIButton。有时候，你会想要自定义这些对象。在对其继承之前，最好查一查，可不可以直接进行更改。比如UIButton就可以更改其标题，背景图片等。</p>

<p>但是，不管怎样，你都有更改属性和方法还是不能满足的时候。这种时候，Cocoa会提供给你一些方法可以进行子类化(subclassing)和重载。</p>

<p>比如UIView，你继承UIView之后，可以对drawRect进行重载，绘制自定义视图。</p>

<p>但是，继承是你在和cocoa交互时，极少会使用到的方式。知道什么时候使用继承是需要技巧的，但是更通用的规则是，如果不是确切的知道该继承，你最好不要使用它。</p>

<p>不使用继承的一个重要原因是，大多数自带的Cocoa类使用委托(delegation)来自定义行为(方法)。</p>

<p>(纯粹看理论会没有实际认知，需要编码去理解。<br/>
知识编码却会陷入似懂非懂的状态，需要整合理论去理解。)</p>

<h2>Categories and Extensions</h2>

<p>OC中Categories指直接在已存在的类上添加方法，Swift中叫作Extensions。</p>

<h3>Swift中如何使用extension？</h3>

<p>例子，Array<T>，多使用extension加少量的protocol。多个extension，把函数体分为多个部分不不是全部在一起，这样使得代码更容易被理解，同时相关联的函数也聚集在一起。<br/>
eg. Core Graphic</p>

<h3>你如何使用extension？</h3>

<p>在已存在的对象类型中添加函数。<br/>
而且它使用于Swift三种类型对象，比如enum和struct不能继承却可以extension。<br/>
一次改变，处处改变。</p>

<p>会在不同的头文件中都有categories的声明，但文档之间没有链接，这也许是cocoa框架结构的问题之一吧。</p>

<h2>Document</h2>

<ul>
<li>Inherits from 继承自何处，不断的向上查看父类，以寻找到你需要的信息。</li>
<li>Conforms to 这怎么翻译，不断的查看其实现的协议(Protocal),以寻找到你需要的信息。</li>
<li>Framework  看该类属于哪个框架，在使用时，需要将框架import你的代码中。</li>
<li>Availability   在什么版本开始可以使用。</li>
<li>Declared in  类被声明在哪一个头文件中。</li>
<li>Related document 相关文档，提高给你有用的信息，比如代码示例。orient your thinking and provide you optionals</li>
<li>Sample code 下一章具体介绍</li>
<li>Body</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14607339861246.html">算法精解：C语言描述</a></h1>
			<p class="meta"><time datetime="2016-04-15T23:26:26+08:00" 
			pubdate data-updated="true">2016/4/15</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>(美)Kyle Loudon, 算法精解：C语言描述</p>

<p>将一个实际问题同我们学到的算法和数据结构相结合起来，这正是软件开发中的一项重要技能——抽象建模能力 <br/>
loc. 222-223 </p>

<p>使用数据结构的三个原因是：效率、抽象和重用性 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 379-380 </p>

<p>换句话说，子问题之间可能有关联。这 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 437-438 </p>

<p>事实上，智能的解决方案通常都是最简单的。另外，最简单的解决方案常常也是最难找到的。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 479-480 </p>

<p>而为数据分配存储空间有两种方法：一种是直接声明一个变量；另一种是在运行时动态地分配存储空间（例如：使用malloc或realloc）。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 539-540 </p>

<p>自动变量是一种在进入或离开一个模块或函数时其存储空间能够自动分配和释放的变量。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 542-543 </p>

<p>内存泄漏问题的产生是由于动态分配了内存空间，但从未释放它（甚至在程序不再使用此数据空间时都不释放它）造成的 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 555-556 </p>

<p>C语言支持两种数据集合：结构和数组。（虽然联合与结构类似，但一般它单独被归为一类。） <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 568-568 </p>

<p>用这些连接起来的结构，我们可以对它们加以组织并用来解决实际的问题。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 571-572 </p>

<p>指出了关于结构指针的另一个重要方面：结构不允许包含自身的实例，但可以包含指向自身实例的指针。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 576-577 </p>

<p>但是同时要知道在C语言中，多维数组其实是以行主序的方式存储的，这也就说明多维数组右边下标变化速度要比由左边下标变化来得更快。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 598-599 </p>

<p>void指针在用来实现数据结构时是非常有用的，因为可以通过void指针存储和检索任何类型的数据。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 657-658 </p>

<p>这是由于泛型指针不会告诉编译器它指向的是何种类型数据，因此编译器既不知道多少个字节要被访问，也不知道应该如何解析字节。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 681-682 </p>

<p>我们对内存中的数据对齐方式必须特别注意。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 684-684 </p>

<p>Notes: 1) zheshishenm 2) 这是什么来着</p>

<p>函数指针将函数当做普通数据那样存储和管理。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 689-689 </p>

<p>以上函数声明的意思是，我们指定了一个函数指针，它接受两个void指针，返回一个整数，命名为match。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 693-694 </p>

<p>用指针把函数另存为数据结构的一部分是C语言一种非常好的特性，因为它可以使数据结构或函数变得更具通用性。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 703-704 </p>

<p>C程序在内存中的组织方式。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 769-769 </p>

<p>输入参数是传递到活跃记录中的参数；输出参数是传递给在活跃记录中调用的函数所使用的。一 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 777-778 </p>

<p>栈是用来存储函数调用信息的绝好方案，这正是由于其后进先出的特点（见第6章）精确满足了函数调用和返回的顺序。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 790-791 </p>

<p>因为递归调用的返回值在一个表达式中使用 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 850-850 </p>

<p>尾递归消除 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 858-858 </p>

<p>我们通常关注的是它的复杂度，复杂度与它处理数据量所需要的资源（通常是时间）的增长速率密切相关。O表示法能够描述一个算法的复杂度。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 950-952 </p>

<p>当观察一个算法的整体构造时，只需要做两步：首先，必须知道算法的哪个部分是由非常量的数据决定的；然后，用函数列出每个部分的性能 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 963-965 </p>

<p>如果不设定一个近似值就无法找到一个“有效的”解决方法。这是一类特殊的问题，称为NP完全问题（NP-complete problem，见本章结尾的相关主题）。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 981-982 </p>

<p>类似O表示法描述的是在一定的条件约束下函数的上限值，θ表示法用来描述函数的区间值。Ω表示法描述的是在一定的条件约束下函数的下限值。O表示法和W表示法类似于O表示法和Ω表示法，只是更精确。在一般情况下经常会用到O表示法，而其他算法则经常用到特殊的场合。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 1036-1039 </p>

<p>由于这些元素是动态分配的（在C语言中调用malloc），因此很重要的一点是，切记这些元素通常实际上都是分散在内存空间中的（见图5-2）。 <br/>
美)Kyle Loudon, 算法精解：C语言描述 (, loc. 1085-1087 </p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14602167511150.html">Design [Note]</a></h1>
			<p class="meta"><time datetime="2016-04-09T23:45:51+08:00" 
			pubdate data-updated="true">2016/4/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>[TOC]</p>

<h1>Motion Design</h1>

<p>设计靠形式来体现内容的感觉。</p>

<p>层次 visual foucs</p>

<ol>
<li>Transition, Focus &amp; Delight</li>
<li>Position, Opacity &amp; Scale

<ul>
<li>Position,</li>
<li>Opacity，浅化，逐渐淡出人们的视野<br/></li>
</ul></li>
<li>Use the three properties. Break the design down.</li>
<li>Color, Rotation &amp; 3D(perspective value -&gt;  the amount of warping)</li>
</ol>

<blockquote>
<p>Slight rotation animations can add a really neat element of interest to an otherwise mundane piece of motion, especially when coupled with spring animation curves which will be discussed later in this guide.(?)</p>
</blockquote>

<h2>Think first</h2>

<p>why you use this animation?</p>

<ul>
<li>What are the initial properties of the item?</li>
<li>What are the final properties of the item?</li>
<li>How long should the animation take?</li>
<li>What&#39;s happening while this item is animating?</li>
<li>What will happen once this item is done animating?</li>
</ul>

<h2>Code it</h2>

<h3>Apple CALayer</h3>

<h3>Framwork</h3>

<h1>Design with animation</h1>

<h2>What is animation?</h2>

<h2>Why? When?</h2>

<ol>
<li>Direct people&#39;s attention. Something is changed.</li>
<li>Where they are and where they go</li>
<li>Connect people&#39;s behavior, fell they are in control. eg. note center
## How do we try animals?
When to use which animation?
How it feels?</li>
<li>Make prototype and get their feedback.</li>
<li>Show</li>
<li>Learn</li>
</ol>

<h2>Example: toast APP.</h2>

<h3>Prototyping Animation.</h3>

<ol>
<li>Tool: Keynote</li>
<li>Why? What&#39;s your goal? What do you want to tell your coustomer?

<ul>
<li>Email</li>
<li>add your favorite toast
### Interactive Prototype</li>
</ul></li>
<li>fell it at hands</li>
<li>let people try it</li>
<li>make changes</li>
</ol>

<p>Peoblem<br/>
Start Change Compete</p>

<blockquote>
<p>Use animation to add character to your app or game.</p>
</blockquote>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="ST.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E6%96%87%E7%AB%A0.html"><strong>文章&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="prose.html"><strong>散文&nbsp;(18)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="story.html"><strong>小说&nbsp;(12)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="HT.html"><strong>社会科学&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ST.html"><strong>科学技术&nbsp;(10)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Argument.html"><strong>论说&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Useful.html"><strong>实用&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="HUM.html"><strong>哲学&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AC%94%E8%AE%B0.html"><strong>笔记&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%BD%92%E6%A1%A3.html"><strong>归档&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="14887861102167.html"></a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14887858399683.html">High Performance iOS APP</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14885089246978.html">亲密关系</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14847990156077.html">车轮上的瓦尔登湖</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14810287448226.html">失乐园</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    



<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-78816000-1', 'auto');
  ga('send', 'pageview');

</script>
<script>
    var _baId = '7e918b457095c138d6ce710350596dfc';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>
</body>
</html>